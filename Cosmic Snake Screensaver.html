<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>宇宙貪食蛇 - Toothless Crystal Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        .hud-text {
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        #start-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.8);
            color: #fff;
            padding: 15px 40px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            border-radius: 50px;
        }
        #start-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="intro-screen" class="text-center">
            <h1 class="text-4xl md:text-6xl font-bold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-cyan-300 via-white to-purple-300" style="filter: drop-shadow(0 0 10px rgba(255,255,255,0.8));">
                TOOTHLESS DANCE
            </h1>
            <p class="text-cyan-100 mb-8 tracking-widest text-sm opacity-80">CRYSTAL EDITION // MAX BPM 500</p>
            <button id="start-btn">開始播放</button>
        </div>
        <div id="hud" class="hidden absolute top-4 left-4 text-left">
            <div class="hud-text text-xl">BPM: <span id="bpm-display">60</span></div>
            <div class="hud-text text-sm opacity-70">PHASE: <span id="phase-display">ACCELERATING</span></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * 系統核心配置
 */
const CONFIG = {
    gridSize: 20,
    baseBPM: 100, // 起始速度稍微快一點配合這首歌
    maxBPM: 500,  // 請求的極限速度
    bpmStep: 2,
    measuresPerChange: 1,
    starCount: 200,
    colors: {
        snakeHead: '#ffffff',
        snakeBody: '#a5f3fc', // 類似水晶的淡青色
        food: '#e879f9', // 粉紫色水晶
        bg: '#050510'
    }
};

/**
 * 音效引擎 - Crystal Melody Edition
 */
class AudioEngine {
    constructor() {
        this.ctx = null;
        this.isReady = false;
        this.melodyIndex = 0;
        
        // Toothless Dance (Driftveil City) Main Riff
        // Frequencies for: F#4, G#4, A4, B4, C#5, D5, E5
        const N = {
            Fs3: 185.00, Gs3: 207.65, A3: 220.00, B3: 246.94,
            Cs4: 277.18, D4: 293.66, E4: 329.63,
            Fs4: 369.99, Gs4: 415.30, A4: 440.00, B4: 493.88,
            Cs5: 554.37, D5: 587.33, E5: 659.25, Fs5: 739.99
        };

        // 簡化的旋律序列 (循環)
        this.melody = [
            // Bar 1
            N.Fs4, N.Fs4, N.A4, N.B4, 
            N.Cs5, N.B4, N.A4, N.B4,
            // Bar 2
            N.Cs5, N.E5, N.D5, N.Cs5, 
            N.B4, N.Cs5, N.B4, N.A4,
            // Bar 3
            N.Fs4, N.Fs4, N.A4, N.B4, 
            N.Cs5, N.B4, N.A4, N.B4,
            // Bar 4 (Variation)
            N.Cs5, N.E5, N.Cs5, N.E5, 
            N.Fs5, N.Cs5, N.B4, N.A4
        ];
    }

    init() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.isReady = true;
    }

    // 播放水晶音色
    playCrystalNote(freq, time, duration = 0.3) {
        if (!freq) return; // Rest

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        // 混合波形：Sine 為主 (清澈)，加一點 Triangle (清脆)
        // 這裡我們用自定義波形或簡單疊加
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, time);

        // 水晶質感包絡線 (Envelope)
        // 快速 Attack, 中等 Decay, 加上一點點延音
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.3, time + 0.01); // 敲擊感
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration); // 餘音繞樑

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start(time);
        osc.stop(time + duration + 0.1);

        // 添加第二個泛音 oscillator 增加 "叮" 的感覺
        const osc2 = this.ctx.createOscillator();
        const gain2 = this.ctx.createGain();
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(freq * 2, time); // 高八度
        gain2.gain.setValueAtTime(0, time);
        gain2.gain.linearRampToValueAtTime(0.05, time + 0.01);
        gain2.gain.exponentialRampToValueAtTime(0.001, time + 0.1); // 很短
        
        osc2.connect(gain2);
        gain2.connect(this.ctx.destination);
        osc2.start(time);
        osc2.stop(time + 0.2);
    }

    // 播放輕柔的貝斯底音
    playBass(time, index) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        
        // 簡單的 Bassline (F# minor)
        // F# -> D -> E -> C#
        let freq = 185.00; // F#3
        const section = Math.floor(index / 8) % 4;
        if (section === 1) freq = 146.83; // D3
        if (section === 2) freq = 164.81; // E3
        if (section === 3) freq = 138.59; // C#3

        osc.frequency.setValueAtTime(freq, time);
        
        gain.gain.setValueAtTime(0.2, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(time);
        osc.stop(time + 0.4);
    }

    playStep(bpmRatio) {
        if (!this.isReady) return;
        const t = this.ctx.currentTime;
        
        // 1. 播放主旋律
        const noteFreq = this.melody[this.melodyIndex % this.melody.length];
        // 根據 BPM 調整音長，速度越快聲音越短促
        const duration = 0.5 - (bpmRatio * 0.4); 
        this.playCrystalNote(noteFreq, t, duration);

        // 2. 每4拍播放一次 Bass (每小節的強拍)
        if (this.melodyIndex % 4 === 0) {
            this.playBass(t, this.melodyIndex);
        }

        this.melodyIndex++;
    }
}

/**
 * 遊戲邏輯與 AI
 */
class Game {
    constructor(canvas, audio) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.audio = audio;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.currentBPM = CONFIG.baseBPM;
        this.bpmDirection = 1;
        this.beatCount = 0;
        
        this.snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}, {x: 7, y: 10}, {x: 6, y: 10}];
        this.direction = {x: 1, y: 0};
        this.nextDirection = {x: 1, y: 0};
        this.food = this.getRandomPos();
        
        this.stars = [];
        this.initStars();

        this.lastTime = 0;
        this.accumulatedTime = 0;
        this.isPlaying = false;
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.cols = Math.floor(this.canvas.width / CONFIG.gridSize);
        this.rows = Math.floor(this.canvas.height / CONFIG.gridSize);
    }

    initStars() {
        for(let i=0; i<CONFIG.starCount; i++) {
            this.stars.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                size: Math.random() * 2,
                alpha: Math.random(),
                speed: Math.random() * 0.5 + 0.1
            });
        }
    }

    getRandomPos() {
        return {
            x: Math.floor(Math.random() * this.cols),
            y: Math.floor(Math.random() * this.rows)
        };
    }

    aiThink() {
        const head = this.snake[0];
        const food = this.food;
        const moves = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];

        const safeMoves = moves.filter(move => {
            const nextX = (head.x + move.x + this.cols) % this.cols;
            const nextY = (head.y + move.y + this.rows) % this.rows;
            // 檢查是否撞到自己
            for (let part of this.snake) {
                if (part.x === nextX && part.y === nextY) return false;
            }
            // 不能回頭
            if (move.x === -this.direction.x && move.y === -this.direction.y) return false;
            return true;
        });

        if (safeMoves.length === 0) return;

        // 貪婪算法：找離食物最近的
        let bestMove = safeMoves[0];
        let minDist = Infinity;

        safeMoves.forEach(move => {
            const nextX = (head.x + move.x + this.cols) % this.cols;
            const nextY = (head.y + move.y + this.rows) % this.rows;
            const dist = Math.abs(nextX - food.x) + Math.abs(nextY - food.y);
            if (dist < minDist) {
                minDist = dist;
                bestMove = move;
            }
        });
        this.nextDirection = bestMove;
    }

    update() {
        this.aiThink();
        this.direction = this.nextDirection;

        const head = {
            x: (this.snake[0].x + this.direction.x + this.cols) % this.cols,
            y: (this.snake[0].y + this.direction.y + this.rows) % this.rows
        };

        // 碰撞檢測
        for (let i = 0; i < this.snake.length; i++) {
            if (head.x === this.snake[i].x && head.y === this.snake[i].y) {
                this.resetGame();
                return;
            }
        }

        this.snake.unshift(head);

        if (head.x === this.food.x && head.y === this.food.y) {
            this.food = this.getRandomPos();
            // 吃東西時給一個特殊的閃亮效果或音效(這裡音效統一在 loop 處理)
        } else {
            this.snake.pop();
        }

        this.handleMusicLogic();
    }

    resetGame() {
        this.snake = [{x: Math.floor(this.cols/2), y: Math.floor(this.rows/2)}];
        this.currentBPM = CONFIG.baseBPM;
        this.audio.melodyIndex = 0;
    }

    handleMusicLogic() {
        const bpmRatio = (this.currentBPM - CONFIG.baseBPM) / (CONFIG.maxBPM - CONFIG.baseBPM);
        
        // 每一步都播放旋律的一個音
        this.audio.playStep(bpmRatio);

        this.beatCount++;

        // 每8個音符(大約2小節)調整一次速度
        if (this.beatCount % 8 === 0) {
            if (this.bpmDirection === 1) {
                this.currentBPM += CONFIG.bpmStep * (1 + bpmRatio * 2);
                if (this.currentBPM >= CONFIG.maxBPM) {
                    this.currentBPM = CONFIG.maxBPM;
                    this.bpmDirection = -1;
                }
            } else {
                this.currentBPM -= CONFIG.bpmStep * 2;
                if (this.currentBPM <= CONFIG.baseBPM) {
                    this.currentBPM = CONFIG.baseBPM;
                    this.bpmDirection = 1;
                }
            }
            
            document.getElementById('bpm-display').innerText = Math.floor(this.currentBPM);
            document.getElementById('phase-display').innerText = this.bpmDirection === 1 ? "ACCELERATING" : "DECELERATING";
        }
    }

    draw() {
        // 背景微光
        this.ctx.fillStyle = 'rgba(5, 5, 16, 0.25)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.drawStars();
        this.drawGlowingRect(this.food.x, this.food.y, CONFIG.colors.food, 15);

        // 繪製蛇
        this.snake.forEach((part, index) => {
            const isHead = index === 0;
            const color = isHead ? CONFIG.colors.snakeHead : CONFIG.colors.snakeBody;
            const bpmRatio = (this.currentBPM - CONFIG.baseBPM) / (CONFIG.maxBPM - CONFIG.baseBPM);
            
            // 蛇身隨音樂閃爍
            const glowBase = isHead ? 20 : 5;
            const pulse = Math.sin(this.beatCount * 0.5 + index) * 5; 
            const glow = glowBase + pulse + (bpmRatio * 15);

            this.drawGlowingRect(part.x, part.y, color, Math.max(0, glow));
        });
    }

    drawStars() {
        // 隨著速度，星星變成流線
        const bpmRatio = (this.currentBPM - CONFIG.baseBPM) / (CONFIG.maxBPM - CONFIG.baseBPM);
        
        this.stars.forEach(star => {
            this.ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
            this.ctx.beginPath();
            
            // 極速視覺效果：星星拉長
            const tailLength = star.size * (1 + bpmRatio * 30);
            
            // 簡單的向後流動效果 (假設蛇往右跑)
            // 這裡我們做一個放射狀或者單向流動
            // 為了簡化，讓星星往左流動
            
            this.ctx.moveTo(star.x, star.y);
            this.ctx.lineTo(star.x - tailLength, star.y);
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${star.alpha})`;
            this.ctx.lineWidth = star.size;
            this.ctx.stroke();
            
            // 更新位置
            star.x -= star.speed * (1 + bpmRatio * 20); // 隨BPM加速
            if (star.x < 0) {
                star.x = this.canvas.width;
                star.y = Math.random() * this.canvas.height;
            }
        });
    }

    drawGlowingRect(gx, gy, color, blur) {
        const x = gx * CONFIG.gridSize;
        const y = gy * CONFIG.gridSize;
        const s = CONFIG.gridSize - 2;

        this.ctx.shadowBlur = blur;
        this.ctx.shadowColor = color;
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + 1, y + 1, s, s);
        this.ctx.shadowBlur = 0;
    }

    start() {
        this.isPlaying = true;
        this.lastTime = performance.now();
        this.audio.init();
        requestAnimationFrame((t) => this.loop(t));
    }

    loop(currentTime) {
        if (!this.isPlaying) return;

        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        this.accumulatedTime += deltaTime;

        // 計算每一步的時間間隔
        // 在 Toothless Dance 中，節奏很快，我們假設每個移動對應旋律的一個音
        // 為了讓它不要快到肉眼看不見，我們將 BPM 定義為「每分鐘的移動次數」
        const stepInterval = 60000 / this.currentBPM; 
        
        if (this.accumulatedTime > stepInterval) {
            this.update();
            this.accumulatedTime -= stepInterval;
        }

        this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }
}

window.onload = () => {
    const canvas = document.getElementById('gameCanvas');
    const startBtn = document.getElementById('start-btn');
    const introScreen = document.getElementById('intro-screen');
    const hud = document.getElementById('hud');
    
    const audio = new AudioEngine();
    const game = new Game(canvas, audio);

    startBtn.addEventListener('click', () => {
        introScreen.classList.add('hidden');
        hud.classList.remove('hidden');
        game.start();
    });
};
</script>
</body>
</html>